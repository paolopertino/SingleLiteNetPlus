// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "experiment_service.proto" (syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message Empty
 */
export interface Empty {
}
/**
 * @generated from protobuf message NeuronId
 */
export interface NeuronId {
    /**
     * @generated from protobuf field: int32 layer_id = 1
     */
    layerId: number;
    /**
     * @generated from protobuf field: int32 neuron_id = 2
     */
    neuronId: number;
}
/**
 * @generated from protobuf message WeightOperation
 */
export interface WeightOperation {
    /**
     * @generated from protobuf field: optional WeightOperationType op_type = 1
     */
    opType?: WeightOperationType;
    /**
     * @generated from protobuf field: optional int32 layer_id = 2
     */
    layerId?: number;
    /**
     * @generated from protobuf field: repeated NeuronId neuron_ids = 3
     */
    neuronIds: NeuronId[];
    /**
     * @generated from protobuf field: int32 neurons_to_add = 9
     */
    neuronsToAdd: number;
    /**
     * @generated from protobuf field: repeated int32 zerofy_from_incoming_ids = 11
     */
    zerofyFromIncomingIds: number[];
    /**
     * @generated from protobuf field: repeated int32 zerofy_to_neuron_ids = 12
     */
    zerofyToNeuronIds: number[];
    /**
     * @generated from protobuf field: repeated ZerofyPredicate zerofy_predicates = 13
     */
    zerofyPredicates: ZerofyPredicate[];
}
/**
 * @generated from protobuf message WeightsOperationRequest
 */
export interface WeightsOperationRequest {
    /**
     * @generated from protobuf field: optional WeightOperation weight_operation = 1
     */
    weightOperation?: WeightOperation;
}
/**
 * @generated from protobuf message WeightsOperationResponse
 */
export interface WeightsOperationResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
/**
 * @generated from protobuf message HyperParameters
 */
export interface HyperParameters {
    /**
     * @generated from protobuf field: optional string experiment_name = 1
     */
    experimentName?: string;
    /**
     * @generated from protobuf field: optional int32 training_steps_to_do = 2
     */
    trainingStepsToDo?: number;
    /**
     * @generated from protobuf field: optional float learning_rate = 3
     */
    learningRate?: number;
    /**
     * @generated from protobuf field: optional int32 batch_size = 4
     */
    batchSize?: number;
    /**
     * @generated from protobuf field: optional int32 full_eval_frequency = 5
     */
    fullEvalFrequency?: number;
    /**
     * @generated from protobuf field: optional int32 checkpont_frequency = 6
     */
    checkpontFrequency?: number;
    /**
     * @generated from protobuf field: optional bool is_training = 7
     */
    isTraining?: boolean;
}
/**
 * @generated from protobuf message MetricsStatus
 */
export interface MetricsStatus {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: float value = 2
     */
    value: number;
}
/**
 * @generated from protobuf message AnnotatStatus
 */
export interface AnnotatStatus {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: map<string, float> metadata = 2
     */
    metadata: {
        [key: string]: number;
    };
}
/**
 * @generated from protobuf message TrainingStatusEx
 */
export interface TrainingStatusEx {
    /**
     * @generated from protobuf field: optional string timestamp = 1
     */
    timestamp?: string;
    /**
     * @generated from protobuf field: optional string experiment_name = 2
     */
    experimentName?: string;
    /**
     * @generated from protobuf field: optional int32 model_age = 3
     */
    modelAge?: number;
    /**
     * @generated from protobuf field: optional MetricsStatus metrics_status = 4
     */
    metricsStatus?: MetricsStatus;
    /**
     * @generated from protobuf field: optional AnnotatStatus annotat_status = 5
     */
    annotatStatus?: AnnotatStatus;
}
/**
 * @generated from protobuf message HyperParameterCommand
 */
export interface HyperParameterCommand {
    /**
     * @generated from protobuf field: optional HyperParameters hyper_parameters = 1
     */
    hyperParameters?: HyperParameters;
}
/**
 * @generated from protobuf message DenySamplesOperation
 */
export interface DenySamplesOperation {
    /**
     * @generated from protobuf field: repeated int32 sample_ids = 1
     */
    sampleIds: number[];
    /**
     * @generated from protobuf field: bool accumulate = 2
     */
    accumulate: boolean;
}
/**
 * @generated from protobuf message LoadCheckpointOperation
 */
export interface LoadCheckpointOperation {
    /**
     * @generated from protobuf field: int32 checkpoint_id = 1
     */
    checkpointId: number;
}
/**
 * @generated from protobuf message TrainerCommand
 */
export interface TrainerCommand {
    /**
     * @generated from protobuf field: bool get_hyper_parameters = 4
     */
    getHyperParameters: boolean;
    /**
     * @generated from protobuf field: bool get_interactive_layers = 5
     */
    getInteractiveLayers: boolean;
    /**
     * @generated from protobuf field: optional string get_data_records = 6
     */
    getDataRecords?: string;
    /**
     * @generated from protobuf field: optional int32 get_single_layer_info_id = 8
     */
    getSingleLayerInfoId?: number;
    /**
     * @generated from protobuf field: optional HyperParameterCommand hyper_parameter_change = 1
     */
    hyperParameterChange?: HyperParameterCommand;
    /**
     * @generated from protobuf field: optional DenySamplesOperation deny_samples_operation = 7
     */
    denySamplesOperation?: DenySamplesOperation;
    /**
     * @generated from protobuf field: optional DenySamplesOperation deny_eval_samples_operation = 10
     */
    denyEvalSamplesOperation?: DenySamplesOperation;
    /**
     * @generated from protobuf field: optional LoadCheckpointOperation load_checkpoint_operation = 9
     */
    loadCheckpointOperation?: LoadCheckpointOperation;
    /**
     * @generated from protobuf field: optional DenySamplesOperation remove_from_denylist_operation = 11
     */
    removeFromDenylistOperation?: DenySamplesOperation;
    /**
     * @generated from protobuf field: optional DenySamplesOperation remove_eval_from_denylist_operation = 12
     */
    removeEvalFromDenylistOperation?: DenySamplesOperation;
}
/**
 * @generated from protobuf message HyperParameterDesc
 */
export interface HyperParameterDesc {
    /**
     * @generated from protobuf field: string label = 1
     */
    label: string;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: string type = 3
     */
    type: string;
    /**
     * @generated from protobuf field: optional float numerical_value = 4
     */
    numericalValue?: number;
    /**
     * @generated from protobuf field: optional string string_value = 5
     */
    stringValue?: string;
}
/**
 * @generated from protobuf message NeuronStatistics
 */
export interface NeuronStatistics {
    /**
     * @generated from protobuf field: optional NeuronId neuron_id = 1
     */
    neuronId?: NeuronId;
    /**
     * @generated from protobuf field: optional int32 neuron_age = 2
     */
    neuronAge?: number;
    /**
     * @generated from protobuf field: optional float train_trigger_rate = 3
     */
    trainTriggerRate?: number;
    /**
     * @generated from protobuf field: optional float eval_trigger_rate = 4
     */
    evalTriggerRate?: number;
    /**
     * @generated from protobuf field: optional float learning_rate = 7
     */
    learningRate?: number;
    /**
     * @generated from protobuf field: map<int32, float> incoming_lr = 8
     */
    incomingLr: {
        [key: number]: number;
    };
}
/**
 * @generated from protobuf message LayerRepresentation
 */
export interface LayerRepresentation {
    /**
     * @generated from protobuf field: optional int32 layer_id = 1
     */
    layerId?: number;
    /**
     * @generated from protobuf field: optional string layer_name = 2
     */
    layerName?: string;
    /**
     * @generated from protobuf field: optional string layer_type = 3
     */
    layerType?: string;
    /**
     * @generated from protobuf field: optional int32 neurons_count = 4
     */
    neuronsCount?: number;
    /**
     * @generated from protobuf field: optional int32 incoming_neurons_count = 5
     */
    incomingNeuronsCount?: number;
    /**
     * @generated from protobuf field: optional int32 kernel_size = 6
     */
    kernelSize?: number;
    /**
     * @generated from protobuf field: optional int32 stride = 7
     */
    stride?: number;
    /**
     * @generated from protobuf field: repeated NeuronStatistics neurons_statistics = 10
     */
    neuronsStatistics: NeuronStatistics[];
}
/**
 * @generated from protobuf message ActivationRequest
 */
export interface ActivationRequest {
    /**
     * @generated from protobuf field: int32 layer_id = 1
     */
    layerId: number;
    /**
     * @generated from protobuf field: int32 sample_id = 2
     */
    sampleId: number;
    /**
     * @generated from protobuf field: string origin = 3
     */
    origin: string;
}
/**
 * @generated from protobuf message ActivationMap
 */
export interface ActivationMap {
    /**
     * @generated from protobuf field: int32 neuron_id = 1
     */
    neuronId: number;
    /**
     * @generated from protobuf field: repeated float values = 2
     */
    values: number[];
    /**
     * @generated from protobuf field: int32 H = 3
     */
    h: number;
    /**
     * @generated from protobuf field: int32 W = 4
     */
    w: number;
}
/**
 * @generated from protobuf message ActivationResponse
 */
export interface ActivationResponse {
    /**
     * @generated from protobuf field: string layer_type = 1
     */
    layerType: string;
    /**
     * @generated from protobuf field: int32 neurons_count = 2
     */
    neuronsCount: number;
    /**
     * @generated from protobuf field: repeated ActivationMap activations = 3
     */
    activations: ActivationMap[];
}
/**
 * @generated from protobuf message TaskField
 */
export interface TaskField {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf oneof: value
     */
    value: {
        oneofKind: "floatValue";
        /**
         * @generated from protobuf field: float float_value = 2
         */
        floatValue: number;
    } | {
        oneofKind: "intValue";
        /**
         * @generated from protobuf field: int32 int_value = 3
         */
        intValue: number;
    } | {
        oneofKind: "stringValue";
        /**
         * @generated from protobuf field: string string_value = 4
         */
        stringValue: string;
    } | {
        oneofKind: "bytesValue";
        /**
         * @generated from protobuf field: bytes bytes_value = 5
         */
        bytesValue: Uint8Array;
    } | {
        oneofKind: "boolValue";
        /**
         * @generated from protobuf field: bool bool_value = 6
         */
        boolValue: boolean;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message RecordMetadata
 */
export interface RecordMetadata {
    /**
     * @generated from protobuf field: int32 sample_id = 1
     */
    sampleId: number;
    /**
     * @generated from protobuf field: repeated int32 sample_label = 2
     */
    sampleLabel: number[];
    /**
     * @generated from protobuf field: repeated int32 sample_prediction = 3
     */
    samplePrediction: number[];
    /**
     * @generated from protobuf field: float sample_last_loss = 4
     */
    sampleLastLoss: number;
    /**
     * @generated from protobuf field: int32 sample_encounters = 5
     */
    sampleEncounters: number;
    /**
     * @generated from protobuf field: bool sample_discarded = 6
     */
    sampleDiscarded: boolean;
    /**
     * @generated from protobuf field: repeated TaskField extra_fields = 7
     */
    extraFields: TaskField[];
    /**
     * @generated from protobuf field: bytes prediction_raw = 9
     */
    predictionRaw: Uint8Array;
    /**
     * @generated from protobuf field: string task_type = 10
     */
    taskType: string;
}
/**
 * @generated from protobuf message SampleStatistics
 */
export interface SampleStatistics {
    /**
     * @generated from protobuf field: optional string origin = 6
     */
    origin?: string;
    /**
     * @generated from protobuf field: optional int32 sample_count = 7
     */
    sampleCount?: number;
    /**
     * @generated from protobuf field: string task_type = 9
     */
    taskType: string;
    /**
     * @generated from protobuf field: repeated RecordMetadata records = 8
     */
    records: RecordMetadata[];
}
/**
 * @generated from protobuf message CommandResponse
 */
export interface CommandResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * @generated from protobuf field: repeated HyperParameterDesc hyper_parameters_descs = 3
     */
    hyperParametersDescs: HyperParameterDesc[];
    /**
     * @generated from protobuf field: repeated LayerRepresentation layer_representations = 4
     */
    layerRepresentations: LayerRepresentation[];
    /**
     * @generated from protobuf field: optional SampleStatistics sample_statistics = 5
     */
    sampleStatistics?: SampleStatistics;
}
/**
 * @generated from protobuf message SampleRequest
 */
export interface SampleRequest {
    /**
     * @generated from protobuf field: optional int32 sample_id = 1
     */
    sampleId?: number;
    /**
     * @generated from protobuf field: optional string origin = 2
     */
    origin?: string;
}
/**
 * @generated from protobuf message SampleRequestResponse
 */
export interface SampleRequestResponse {
    /**
     * @generated from protobuf field: optional int32 sample_id = 1
     */
    sampleId?: number;
    /**
     * @generated from protobuf field: optional string origin = 2
     */
    origin?: string;
    /**
     * @generated from protobuf field: optional int32 label = 3
     */
    label?: number;
    /**
     * @generated from protobuf field: optional bytes data = 4
     */
    data?: Uint8Array;
    /**
     * @generated from protobuf field: optional string error_message = 5
     */
    errorMessage?: string;
    /**
     * @generated from protobuf field: optional bytes raw_data = 6
     */
    rawData?: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes mask = 7
     */
    mask?: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes prediction = 8
     */
    prediction?: Uint8Array;
}
/**
 * @generated from protobuf message BatchSampleRequest
 */
export interface BatchSampleRequest {
    /**
     * @generated from protobuf field: repeated int32 sample_ids = 1
     */
    sampleIds: number[];
    /**
     * @generated from protobuf field: string origin = 2
     */
    origin: string;
    /**
     * @generated from protobuf field: optional int32 resize_width = 3
     */
    resizeWidth?: number;
    /**
     * @generated from protobuf field: optional int32 resize_height = 4
     */
    resizeHeight?: number;
}
/**
 * @generated from protobuf message BatchSampleResponse
 */
export interface BatchSampleResponse {
    /**
     * @generated from protobuf field: repeated SampleRequestResponse samples = 1
     */
    samples: SampleRequestResponse[];
}
/**
 * @generated from protobuf message WeightsRequest
 */
export interface WeightsRequest {
    /**
     * @generated from protobuf field: NeuronId neuron_id = 1
     */
    neuronId?: NeuronId;
}
/**
 * @generated from protobuf message WeightsResponse
 */
export interface WeightsResponse {
    /**
     * @generated from protobuf field: NeuronId neuron_id = 1
     */
    neuronId?: NeuronId;
    /**
     * @generated from protobuf field: optional string layer_name = 2
     */
    layerName?: string;
    /**
     * @generated from protobuf field: optional string layer_type = 3
     */
    layerType?: string;
    /**
     * @generated from protobuf field: int32 incoming = 4
     */
    incoming: number;
    /**
     * @generated from protobuf field: int32 outgoing = 5
     */
    outgoing: number;
    /**
     * @generated from protobuf field: optional int32 kernel_size = 6
     */
    kernelSize?: number;
    /**
     * @generated from protobuf field: repeated float weights = 7
     */
    weights: number[];
    /**
     * @generated from protobuf field: bool success = 11
     */
    success: boolean;
    /**
     * @generated from protobuf field: optional string error_message = 12
     */
    errorMessage?: string;
}
// ============================================================================
// Data Service Messages (for weights_studio UI integration)
// ============================================================================

/**
 * @generated from protobuf message DataQueryRequest
 */
export interface DataQueryRequest {
    /**
     * @generated from protobuf field: string query = 1
     */
    query: string;
    /**
     * @generated from protobuf field: bool accumulate = 2
     */
    accumulate: boolean;
    /**
     * @generated from protobuf field: bool is_natural_language = 3
     */
    isNaturalLanguage: boolean;
}
/**
 * @generated from protobuf message DataQueryResponse
 */
export interface DataQueryResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * @generated from protobuf field: int32 number_of_all_samples = 3
     */
    numberOfAllSamples: number;
    /**
     * @generated from protobuf field: int32 number_of_samples_in_the_loop = 4
     */
    numberOfSamplesInTheLoop: number;
    /**
     * @generated from protobuf field: int32 number_of_discarded_samples = 5
     */
    numberOfDiscardedSamples: number;
}
/**
 * @generated from protobuf message DataSamplesRequest
 */
export interface DataSamplesRequest {
    /**
     * @generated from protobuf field: int32 start_index = 1
     */
    startIndex: number;
    /**
     * @generated from protobuf field: int32 records_cnt = 2
     */
    recordsCnt: number;
    /**
     * @generated from protobuf field: bool include_transformed_data = 3
     */
    includeTransformedData: boolean;
    /**
     * @generated from protobuf field: bool include_raw_data = 4
     */
    includeRawData: boolean;
    /**
     * @generated from protobuf field: repeated string stats_to_retrieve = 5
     */
    statsToRetrieve: string[];
}
/**
 * @generated from protobuf message DataStat
 */
export interface DataStat {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: string type = 2
     */
    type: string;
    /**
     * @generated from protobuf field: repeated int32 shape = 3
     */
    shape: number[];
    /**
     * @generated from protobuf field: repeated float value = 4
     */
    value: number[];
    /**
     * @generated from protobuf field: string value_string = 5
     */
    valueString: string;
}
/**
 * @generated from protobuf message DataRecord
 */
export interface DataRecord {
    /**
     * @generated from protobuf field: int32 sample_id = 1
     */
    sampleId: number;
    /**
     * @generated from protobuf field: repeated DataStat data_stats = 2
     */
    dataStats: DataStat[];
}
/**
 * @generated from protobuf message DataSamplesResponse
 */
export interface DataSamplesResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * @generated from protobuf field: repeated DataRecord data_records = 3
     */
    dataRecords: DataRecord[];
}
/**
 * @generated from protobuf message DataEditsRequest
 */
export interface DataEditsRequest {
    /**
     * @generated from protobuf field: string stat_name = 1
     */
    statName: string;
    /**
     * @generated from protobuf field: float float_value = 2
     */
    floatValue: number;
    /**
     * @generated from protobuf field: string string_value = 3
     */
    stringValue: string;
    /**
     * @generated from protobuf field: bool bool_value = 4
     */
    boolValue: boolean;
    /**
     * @generated from protobuf field: SampleEditType type = 5
     */
    type: SampleEditType;
    /**
     * @generated from protobuf field: repeated int32 samples_ids = 6
     */
    samplesIds: number[];
    /**
     * @generated from protobuf field: repeated string sample_origins = 7
     */
    sampleOrigins: string[];
}
/**
 * @generated from protobuf message DataEditsResponse
 */
export interface DataEditsResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
/**
 * @generated from protobuf message DataStreamRequest
 */
export interface DataStreamRequest {
    /**
     * @generated from protobuf field: string query = 1
     */
    query: string; // Filter query (e.g., "loss > 2")
    /**
     * @generated from protobuf field: bool is_natural_language = 2
     */
    isNaturalLanguage: boolean; // Whether query is natural language
    /**
     * @generated from protobuf field: int32 max_samples = 3
     */
    maxSamples: number; // Max samples to return per update (0 = all)
    /**
     * @generated from protobuf field: int32 start_index = 4
     */
    startIndex: number; // Starting index for samples
}
/**
 * @generated from protobuf enum WeightOperationType
 */
export enum WeightOperationType {
    /**
     * @generated from protobuf enum value: ZEROFY = 0;
     */
    ZEROFY = 0,
    /**
     * @generated from protobuf enum value: REINITIALIZE = 1;
     */
    REINITIALIZE = 1,
    /**
     * @generated from protobuf enum value: FREEZE = 2;
     */
    FREEZE = 2,
    /**
     * @generated from protobuf enum value: REMOVE_NEURONS = 9;
     */
    REMOVE_NEURONS = 9,
    /**
     * @generated from protobuf enum value: ADD_NEURONS = 10;
     */
    ADD_NEURONS = 10
}
/**
 * @generated from protobuf enum ZerofyPredicate
 */
export enum ZerofyPredicate {
    /**
     * @generated from protobuf enum value: ZEROFY_PREDICATE_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: ZEROFY_PREDICATE_WITH_FROZEN = 1;
     */
    WITH_FROZEN = 1,
    /**
     * @generated from protobuf enum value: ZEROFY_PREDICATE_WITH_OLDER = 2;
     */
    WITH_OLDER = 2
}
/**
 * @generated from protobuf enum SampleEditType
 */
export enum SampleEditType {
    /**
     * @generated from protobuf enum value: EDIT_OVERRIDE = 0;
     */
    EDIT_OVERRIDE = 0,
    /**
     * @generated from protobuf enum value: EDIT_ACCUMULATE = 1;
     */
    EDIT_ACCUMULATE = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class Empty$Type extends MessageType<Empty> {
    constructor() {
        super("Empty", []);
    }
    create(value?: PartialMessage<Empty>): Empty {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Empty>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Empty): Empty {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Empty, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Empty
 */
export const Empty = new Empty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NeuronId$Type extends MessageType<NeuronId> {
    constructor() {
        super("NeuronId", [
            { no: 1, name: "layer_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "neuron_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<NeuronId>): NeuronId {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.layerId = 0;
        message.neuronId = 0;
        if (value !== undefined)
            reflectionMergePartial<NeuronId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NeuronId): NeuronId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 layer_id */ 1:
                    message.layerId = reader.int32();
                    break;
                case /* int32 neuron_id */ 2:
                    message.neuronId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NeuronId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 layer_id = 1; */
        if (message.layerId !== 0)
            writer.tag(1, WireType.Varint).int32(message.layerId);
        /* int32 neuron_id = 2; */
        if (message.neuronId !== 0)
            writer.tag(2, WireType.Varint).int32(message.neuronId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message NeuronId
 */
export const NeuronId = new NeuronId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WeightOperation$Type extends MessageType<WeightOperation> {
    constructor() {
        super("WeightOperation", [
            { no: 1, name: "op_type", kind: "enum", opt: true, T: () => ["WeightOperationType", WeightOperationType] },
            { no: 2, name: "layer_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "neuron_ids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => NeuronId },
            { no: 9, name: "neurons_to_add", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "zerofy_from_incoming_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "zerofy_to_neuron_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "zerofy_predicates", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["ZerofyPredicate", ZerofyPredicate, "ZEROFY_PREDICATE_"] }
        ]);
    }
    create(value?: PartialMessage<WeightOperation>): WeightOperation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.neuronIds = [];
        message.neuronsToAdd = 0;
        message.zerofyFromIncomingIds = [];
        message.zerofyToNeuronIds = [];
        message.zerofyPredicates = [];
        if (value !== undefined)
            reflectionMergePartial<WeightOperation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WeightOperation): WeightOperation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional WeightOperationType op_type */ 1:
                    message.opType = reader.int32();
                    break;
                case /* optional int32 layer_id */ 2:
                    message.layerId = reader.int32();
                    break;
                case /* repeated NeuronId neuron_ids */ 3:
                    message.neuronIds.push(NeuronId.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 neurons_to_add */ 9:
                    message.neuronsToAdd = reader.int32();
                    break;
                case /* repeated int32 zerofy_from_incoming_ids */ 11:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.zerofyFromIncomingIds.push(reader.int32());
                    else
                        message.zerofyFromIncomingIds.push(reader.int32());
                    break;
                case /* repeated int32 zerofy_to_neuron_ids */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.zerofyToNeuronIds.push(reader.int32());
                    else
                        message.zerofyToNeuronIds.push(reader.int32());
                    break;
                case /* repeated ZerofyPredicate zerofy_predicates */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.zerofyPredicates.push(reader.int32());
                    else
                        message.zerofyPredicates.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WeightOperation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional WeightOperationType op_type = 1; */
        if (message.opType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.opType);
        /* optional int32 layer_id = 2; */
        if (message.layerId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.layerId);
        /* repeated NeuronId neuron_ids = 3; */
        for (let i = 0; i < message.neuronIds.length; i++)
            NeuronId.internalBinaryWrite(message.neuronIds[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int32 neurons_to_add = 9; */
        if (message.neuronsToAdd !== 0)
            writer.tag(9, WireType.Varint).int32(message.neuronsToAdd);
        /* repeated int32 zerofy_from_incoming_ids = 11; */
        if (message.zerofyFromIncomingIds.length) {
            writer.tag(11, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.zerofyFromIncomingIds.length; i++)
                writer.int32(message.zerofyFromIncomingIds[i]);
            writer.join();
        }
        /* repeated int32 zerofy_to_neuron_ids = 12; */
        if (message.zerofyToNeuronIds.length) {
            writer.tag(12, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.zerofyToNeuronIds.length; i++)
                writer.int32(message.zerofyToNeuronIds[i]);
            writer.join();
        }
        /* repeated ZerofyPredicate zerofy_predicates = 13; */
        if (message.zerofyPredicates.length) {
            writer.tag(13, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.zerofyPredicates.length; i++)
                writer.int32(message.zerofyPredicates[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WeightOperation
 */
export const WeightOperation = new WeightOperation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WeightsOperationRequest$Type extends MessageType<WeightsOperationRequest> {
    constructor() {
        super("WeightsOperationRequest", [
            { no: 1, name: "weight_operation", kind: "message", T: () => WeightOperation }
        ]);
    }
    create(value?: PartialMessage<WeightsOperationRequest>): WeightsOperationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<WeightsOperationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WeightsOperationRequest): WeightsOperationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional WeightOperation weight_operation */ 1:
                    message.weightOperation = WeightOperation.internalBinaryRead(reader, reader.uint32(), options, message.weightOperation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WeightsOperationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional WeightOperation weight_operation = 1; */
        if (message.weightOperation)
            WeightOperation.internalBinaryWrite(message.weightOperation, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WeightsOperationRequest
 */
export const WeightsOperationRequest = new WeightsOperationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WeightsOperationResponse$Type extends MessageType<WeightsOperationResponse> {
    constructor() {
        super("WeightsOperationResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WeightsOperationResponse>): WeightsOperationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<WeightsOperationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WeightsOperationResponse): WeightsOperationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WeightsOperationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WeightsOperationResponse
 */
export const WeightsOperationResponse = new WeightsOperationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HyperParameters$Type extends MessageType<HyperParameters> {
    constructor() {
        super("HyperParameters", [
            { no: 1, name: "experiment_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "training_steps_to_do", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "learning_rate", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "batch_size", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "full_eval_frequency", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "checkpont_frequency", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "is_training", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<HyperParameters>): HyperParameters {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HyperParameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HyperParameters): HyperParameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string experiment_name */ 1:
                    message.experimentName = reader.string();
                    break;
                case /* optional int32 training_steps_to_do */ 2:
                    message.trainingStepsToDo = reader.int32();
                    break;
                case /* optional float learning_rate */ 3:
                    message.learningRate = reader.float();
                    break;
                case /* optional int32 batch_size */ 4:
                    message.batchSize = reader.int32();
                    break;
                case /* optional int32 full_eval_frequency */ 5:
                    message.fullEvalFrequency = reader.int32();
                    break;
                case /* optional int32 checkpont_frequency */ 6:
                    message.checkpontFrequency = reader.int32();
                    break;
                case /* optional bool is_training */ 7:
                    message.isTraining = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HyperParameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string experiment_name = 1; */
        if (message.experimentName !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.experimentName);
        /* optional int32 training_steps_to_do = 2; */
        if (message.trainingStepsToDo !== undefined)
            writer.tag(2, WireType.Varint).int32(message.trainingStepsToDo);
        /* optional float learning_rate = 3; */
        if (message.learningRate !== undefined)
            writer.tag(3, WireType.Bit32).float(message.learningRate);
        /* optional int32 batch_size = 4; */
        if (message.batchSize !== undefined)
            writer.tag(4, WireType.Varint).int32(message.batchSize);
        /* optional int32 full_eval_frequency = 5; */
        if (message.fullEvalFrequency !== undefined)
            writer.tag(5, WireType.Varint).int32(message.fullEvalFrequency);
        /* optional int32 checkpont_frequency = 6; */
        if (message.checkpontFrequency !== undefined)
            writer.tag(6, WireType.Varint).int32(message.checkpontFrequency);
        /* optional bool is_training = 7; */
        if (message.isTraining !== undefined)
            writer.tag(7, WireType.Varint).bool(message.isTraining);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HyperParameters
 */
export const HyperParameters = new HyperParameters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MetricsStatus$Type extends MessageType<MetricsStatus> {
    constructor() {
        super("MetricsStatus", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<MetricsStatus>): MetricsStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.value = 0;
        if (value !== undefined)
            reflectionMergePartial<MetricsStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MetricsStatus): MetricsStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* float value */ 2:
                    message.value = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MetricsStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* float value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Bit32).float(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MetricsStatus
 */
export const MetricsStatus = new MetricsStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnnotatStatus$Type extends MessageType<AnnotatStatus> {
    constructor() {
        super("AnnotatStatus", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 2 /*ScalarType.FLOAT*/ } }
        ]);
    }
    create(value?: PartialMessage<AnnotatStatus>): AnnotatStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.metadata = {};
        if (value !== undefined)
            reflectionMergePartial<AnnotatStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AnnotatStatus): AnnotatStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* map<string, float> metadata */ 2:
                    this.binaryReadMap2(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: AnnotatStatus["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AnnotatStatus["metadata"] | undefined, val: AnnotatStatus["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.float();
                    break;
                default: throw new globalThis.Error("unknown map entry field for AnnotatStatus.metadata");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: AnnotatStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* map<string, float> metadata = 2; */
        for (let k of globalThis.Object.keys(message.metadata))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Bit32).float(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AnnotatStatus
 */
export const AnnotatStatus = new AnnotatStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrainingStatusEx$Type extends MessageType<TrainingStatusEx> {
    constructor() {
        super("TrainingStatusEx", [
            { no: 1, name: "timestamp", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "experiment_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "model_age", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "metrics_status", kind: "message", T: () => MetricsStatus },
            { no: 5, name: "annotat_status", kind: "message", T: () => AnnotatStatus }
        ]);
    }
    create(value?: PartialMessage<TrainingStatusEx>): TrainingStatusEx {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TrainingStatusEx>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrainingStatusEx): TrainingStatusEx {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string timestamp */ 1:
                    message.timestamp = reader.string();
                    break;
                case /* optional string experiment_name */ 2:
                    message.experimentName = reader.string();
                    break;
                case /* optional int32 model_age */ 3:
                    message.modelAge = reader.int32();
                    break;
                case /* optional MetricsStatus metrics_status */ 4:
                    message.metricsStatus = MetricsStatus.internalBinaryRead(reader, reader.uint32(), options, message.metricsStatus);
                    break;
                case /* optional AnnotatStatus annotat_status */ 5:
                    message.annotatStatus = AnnotatStatus.internalBinaryRead(reader, reader.uint32(), options, message.annotatStatus);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrainingStatusEx, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string timestamp = 1; */
        if (message.timestamp !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.timestamp);
        /* optional string experiment_name = 2; */
        if (message.experimentName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.experimentName);
        /* optional int32 model_age = 3; */
        if (message.modelAge !== undefined)
            writer.tag(3, WireType.Varint).int32(message.modelAge);
        /* optional MetricsStatus metrics_status = 4; */
        if (message.metricsStatus)
            MetricsStatus.internalBinaryWrite(message.metricsStatus, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional AnnotatStatus annotat_status = 5; */
        if (message.annotatStatus)
            AnnotatStatus.internalBinaryWrite(message.annotatStatus, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TrainingStatusEx
 */
export const TrainingStatusEx = new TrainingStatusEx$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HyperParameterCommand$Type extends MessageType<HyperParameterCommand> {
    constructor() {
        super("HyperParameterCommand", [
            { no: 1, name: "hyper_parameters", kind: "message", T: () => HyperParameters }
        ]);
    }
    create(value?: PartialMessage<HyperParameterCommand>): HyperParameterCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HyperParameterCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HyperParameterCommand): HyperParameterCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional HyperParameters hyper_parameters */ 1:
                    message.hyperParameters = HyperParameters.internalBinaryRead(reader, reader.uint32(), options, message.hyperParameters);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HyperParameterCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional HyperParameters hyper_parameters = 1; */
        if (message.hyperParameters)
            HyperParameters.internalBinaryWrite(message.hyperParameters, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HyperParameterCommand
 */
export const HyperParameterCommand = new HyperParameterCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DenySamplesOperation$Type extends MessageType<DenySamplesOperation> {
    constructor() {
        super("DenySamplesOperation", [
            { no: 1, name: "sample_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "accumulate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DenySamplesOperation>): DenySamplesOperation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sampleIds = [];
        message.accumulate = false;
        if (value !== undefined)
            reflectionMergePartial<DenySamplesOperation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DenySamplesOperation): DenySamplesOperation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 sample_ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.sampleIds.push(reader.int32());
                    else
                        message.sampleIds.push(reader.int32());
                    break;
                case /* bool accumulate */ 2:
                    message.accumulate = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DenySamplesOperation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 sample_ids = 1; */
        if (message.sampleIds.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.sampleIds.length; i++)
                writer.int32(message.sampleIds[i]);
            writer.join();
        }
        /* bool accumulate = 2; */
        if (message.accumulate !== false)
            writer.tag(2, WireType.Varint).bool(message.accumulate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DenySamplesOperation
 */
export const DenySamplesOperation = new DenySamplesOperation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoadCheckpointOperation$Type extends MessageType<LoadCheckpointOperation> {
    constructor() {
        super("LoadCheckpointOperation", [
            { no: 1, name: "checkpoint_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<LoadCheckpointOperation>): LoadCheckpointOperation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.checkpointId = 0;
        if (value !== undefined)
            reflectionMergePartial<LoadCheckpointOperation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoadCheckpointOperation): LoadCheckpointOperation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 checkpoint_id */ 1:
                    message.checkpointId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoadCheckpointOperation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 checkpoint_id = 1; */
        if (message.checkpointId !== 0)
            writer.tag(1, WireType.Varint).int32(message.checkpointId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LoadCheckpointOperation
 */
export const LoadCheckpointOperation = new LoadCheckpointOperation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrainerCommand$Type extends MessageType<TrainerCommand> {
    constructor() {
        super("TrainerCommand", [
            { no: 4, name: "get_hyper_parameters", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "get_interactive_layers", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "get_data_records", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "get_single_layer_info_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 1, name: "hyper_parameter_change", kind: "message", T: () => HyperParameterCommand },
            { no: 7, name: "deny_samples_operation", kind: "message", T: () => DenySamplesOperation },
            { no: 10, name: "deny_eval_samples_operation", kind: "message", T: () => DenySamplesOperation },
            { no: 9, name: "load_checkpoint_operation", kind: "message", T: () => LoadCheckpointOperation },
            { no: 11, name: "remove_from_denylist_operation", kind: "message", T: () => DenySamplesOperation },
            { no: 12, name: "remove_eval_from_denylist_operation", kind: "message", T: () => DenySamplesOperation }
        ]);
    }
    create(value?: PartialMessage<TrainerCommand>): TrainerCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.getHyperParameters = false;
        message.getInteractiveLayers = false;
        if (value !== undefined)
            reflectionMergePartial<TrainerCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrainerCommand): TrainerCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool get_hyper_parameters */ 4:
                    message.getHyperParameters = reader.bool();
                    break;
                case /* bool get_interactive_layers */ 5:
                    message.getInteractiveLayers = reader.bool();
                    break;
                case /* optional string get_data_records */ 6:
                    message.getDataRecords = reader.string();
                    break;
                case /* optional int32 get_single_layer_info_id */ 8:
                    message.getSingleLayerInfoId = reader.int32();
                    break;
                case /* optional HyperParameterCommand hyper_parameter_change */ 1:
                    message.hyperParameterChange = HyperParameterCommand.internalBinaryRead(reader, reader.uint32(), options, message.hyperParameterChange);
                    break;
                case /* optional DenySamplesOperation deny_samples_operation */ 7:
                    message.denySamplesOperation = DenySamplesOperation.internalBinaryRead(reader, reader.uint32(), options, message.denySamplesOperation);
                    break;
                case /* optional DenySamplesOperation deny_eval_samples_operation */ 10:
                    message.denyEvalSamplesOperation = DenySamplesOperation.internalBinaryRead(reader, reader.uint32(), options, message.denyEvalSamplesOperation);
                    break;
                case /* optional LoadCheckpointOperation load_checkpoint_operation */ 9:
                    message.loadCheckpointOperation = LoadCheckpointOperation.internalBinaryRead(reader, reader.uint32(), options, message.loadCheckpointOperation);
                    break;
                case /* optional DenySamplesOperation remove_from_denylist_operation */ 11:
                    message.removeFromDenylistOperation = DenySamplesOperation.internalBinaryRead(reader, reader.uint32(), options, message.removeFromDenylistOperation);
                    break;
                case /* optional DenySamplesOperation remove_eval_from_denylist_operation */ 12:
                    message.removeEvalFromDenylistOperation = DenySamplesOperation.internalBinaryRead(reader, reader.uint32(), options, message.removeEvalFromDenylistOperation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrainerCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional HyperParameterCommand hyper_parameter_change = 1; */
        if (message.hyperParameterChange)
            HyperParameterCommand.internalBinaryWrite(message.hyperParameterChange, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool get_hyper_parameters = 4; */
        if (message.getHyperParameters !== false)
            writer.tag(4, WireType.Varint).bool(message.getHyperParameters);
        /* bool get_interactive_layers = 5; */
        if (message.getInteractiveLayers !== false)
            writer.tag(5, WireType.Varint).bool(message.getInteractiveLayers);
        /* optional string get_data_records = 6; */
        if (message.getDataRecords !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.getDataRecords);
        /* optional DenySamplesOperation deny_samples_operation = 7; */
        if (message.denySamplesOperation)
            DenySamplesOperation.internalBinaryWrite(message.denySamplesOperation, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 get_single_layer_info_id = 8; */
        if (message.getSingleLayerInfoId !== undefined)
            writer.tag(8, WireType.Varint).int32(message.getSingleLayerInfoId);
        /* optional LoadCheckpointOperation load_checkpoint_operation = 9; */
        if (message.loadCheckpointOperation)
            LoadCheckpointOperation.internalBinaryWrite(message.loadCheckpointOperation, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional DenySamplesOperation deny_eval_samples_operation = 10; */
        if (message.denyEvalSamplesOperation)
            DenySamplesOperation.internalBinaryWrite(message.denyEvalSamplesOperation, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* optional DenySamplesOperation remove_from_denylist_operation = 11; */
        if (message.removeFromDenylistOperation)
            DenySamplesOperation.internalBinaryWrite(message.removeFromDenylistOperation, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* optional DenySamplesOperation remove_eval_from_denylist_operation = 12; */
        if (message.removeEvalFromDenylistOperation)
            DenySamplesOperation.internalBinaryWrite(message.removeEvalFromDenylistOperation, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TrainerCommand
 */
export const TrainerCommand = new TrainerCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HyperParameterDesc$Type extends MessageType<HyperParameterDesc> {
    constructor() {
        super("HyperParameterDesc", [
            { no: 1, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "numerical_value", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "string_value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HyperParameterDesc>): HyperParameterDesc {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.label = "";
        message.name = "";
        message.type = "";
        if (value !== undefined)
            reflectionMergePartial<HyperParameterDesc>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HyperParameterDesc): HyperParameterDesc {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string type */ 3:
                    message.type = reader.string();
                    break;
                case /* optional float numerical_value */ 4:
                    message.numericalValue = reader.float();
                    break;
                case /* optional string string_value */ 5:
                    message.stringValue = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HyperParameterDesc, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string type = 3; */
        if (message.type !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.type);
        /* optional float numerical_value = 4; */
        if (message.numericalValue !== undefined)
            writer.tag(4, WireType.Bit32).float(message.numericalValue);
        /* optional string string_value = 5; */
        if (message.stringValue !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.stringValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HyperParameterDesc
 */
export const HyperParameterDesc = new HyperParameterDesc$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NeuronStatistics$Type extends MessageType<NeuronStatistics> {
    constructor() {
        super("NeuronStatistics", [
            { no: 1, name: "neuron_id", kind: "message", T: () => NeuronId },
            { no: 2, name: "neuron_age", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "train_trigger_rate", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "eval_trigger_rate", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "learning_rate", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "incoming_lr", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 2 /*ScalarType.FLOAT*/ } }
        ]);
    }
    create(value?: PartialMessage<NeuronStatistics>): NeuronStatistics {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.incomingLr = {};
        if (value !== undefined)
            reflectionMergePartial<NeuronStatistics>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NeuronStatistics): NeuronStatistics {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional NeuronId neuron_id */ 1:
                    message.neuronId = NeuronId.internalBinaryRead(reader, reader.uint32(), options, message.neuronId);
                    break;
                case /* optional int32 neuron_age */ 2:
                    message.neuronAge = reader.int32();
                    break;
                case /* optional float train_trigger_rate */ 3:
                    message.trainTriggerRate = reader.float();
                    break;
                case /* optional float eval_trigger_rate */ 4:
                    message.evalTriggerRate = reader.float();
                    break;
                case /* optional float learning_rate */ 7:
                    message.learningRate = reader.float();
                    break;
                case /* map<int32, float> incoming_lr */ 8:
                    this.binaryReadMap8(message.incomingLr, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: NeuronStatistics["incomingLr"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof NeuronStatistics["incomingLr"] | undefined, val: NeuronStatistics["incomingLr"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.float();
                    break;
                default: throw new globalThis.Error("unknown map entry field for NeuronStatistics.incoming_lr");
            }
        }
        map[key ?? 0] = val ?? 0;
    }
    internalBinaryWrite(message: NeuronStatistics, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional NeuronId neuron_id = 1; */
        if (message.neuronId)
            NeuronId.internalBinaryWrite(message.neuronId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 neuron_age = 2; */
        if (message.neuronAge !== undefined)
            writer.tag(2, WireType.Varint).int32(message.neuronAge);
        /* optional float train_trigger_rate = 3; */
        if (message.trainTriggerRate !== undefined)
            writer.tag(3, WireType.Bit32).float(message.trainTriggerRate);
        /* optional float eval_trigger_rate = 4; */
        if (message.evalTriggerRate !== undefined)
            writer.tag(4, WireType.Bit32).float(message.evalTriggerRate);
        /* optional float learning_rate = 7; */
        if (message.learningRate !== undefined)
            writer.tag(7, WireType.Bit32).float(message.learningRate);
        /* map<int32, float> incoming_lr = 8; */
        for (let k of globalThis.Object.keys(message.incomingLr))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Bit32).float(message.incomingLr[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message NeuronStatistics
 */
export const NeuronStatistics = new NeuronStatistics$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LayerRepresentation$Type extends MessageType<LayerRepresentation> {
    constructor() {
        super("LayerRepresentation", [
            { no: 1, name: "layer_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "layer_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "layer_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "neurons_count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "incoming_neurons_count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "kernel_size", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "stride", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "neurons_statistics", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => NeuronStatistics }
        ]);
    }
    create(value?: PartialMessage<LayerRepresentation>): LayerRepresentation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.neuronsStatistics = [];
        if (value !== undefined)
            reflectionMergePartial<LayerRepresentation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LayerRepresentation): LayerRepresentation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 layer_id */ 1:
                    message.layerId = reader.int32();
                    break;
                case /* optional string layer_name */ 2:
                    message.layerName = reader.string();
                    break;
                case /* optional string layer_type */ 3:
                    message.layerType = reader.string();
                    break;
                case /* optional int32 neurons_count */ 4:
                    message.neuronsCount = reader.int32();
                    break;
                case /* optional int32 incoming_neurons_count */ 5:
                    message.incomingNeuronsCount = reader.int32();
                    break;
                case /* optional int32 kernel_size */ 6:
                    message.kernelSize = reader.int32();
                    break;
                case /* optional int32 stride */ 7:
                    message.stride = reader.int32();
                    break;
                case /* repeated NeuronStatistics neurons_statistics */ 10:
                    message.neuronsStatistics.push(NeuronStatistics.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LayerRepresentation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 layer_id = 1; */
        if (message.layerId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.layerId);
        /* optional string layer_name = 2; */
        if (message.layerName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.layerName);
        /* optional string layer_type = 3; */
        if (message.layerType !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.layerType);
        /* optional int32 neurons_count = 4; */
        if (message.neuronsCount !== undefined)
            writer.tag(4, WireType.Varint).int32(message.neuronsCount);
        /* optional int32 incoming_neurons_count = 5; */
        if (message.incomingNeuronsCount !== undefined)
            writer.tag(5, WireType.Varint).int32(message.incomingNeuronsCount);
        /* optional int32 kernel_size = 6; */
        if (message.kernelSize !== undefined)
            writer.tag(6, WireType.Varint).int32(message.kernelSize);
        /* optional int32 stride = 7; */
        if (message.stride !== undefined)
            writer.tag(7, WireType.Varint).int32(message.stride);
        /* repeated NeuronStatistics neurons_statistics = 10; */
        for (let i = 0; i < message.neuronsStatistics.length; i++)
            NeuronStatistics.internalBinaryWrite(message.neuronsStatistics[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LayerRepresentation
 */
export const LayerRepresentation = new LayerRepresentation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivationRequest$Type extends MessageType<ActivationRequest> {
    constructor() {
        super("ActivationRequest", [
            { no: 1, name: "layer_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "sample_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "origin", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ActivationRequest>): ActivationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.layerId = 0;
        message.sampleId = 0;
        message.origin = "";
        if (value !== undefined)
            reflectionMergePartial<ActivationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActivationRequest): ActivationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 layer_id */ 1:
                    message.layerId = reader.int32();
                    break;
                case /* int32 sample_id */ 2:
                    message.sampleId = reader.int32();
                    break;
                case /* string origin */ 3:
                    message.origin = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActivationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 layer_id = 1; */
        if (message.layerId !== 0)
            writer.tag(1, WireType.Varint).int32(message.layerId);
        /* int32 sample_id = 2; */
        if (message.sampleId !== 0)
            writer.tag(2, WireType.Varint).int32(message.sampleId);
        /* string origin = 3; */
        if (message.origin !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.origin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ActivationRequest
 */
export const ActivationRequest = new ActivationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivationMap$Type extends MessageType<ActivationMap> {
    constructor() {
        super("ActivationMap", [
            { no: 1, name: "neuron_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "values", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "H", kind: "scalar", jsonName: "H", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "W", kind: "scalar", jsonName: "W", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ActivationMap>): ActivationMap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.neuronId = 0;
        message.values = [];
        message.h = 0;
        message.w = 0;
        if (value !== undefined)
            reflectionMergePartial<ActivationMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActivationMap): ActivationMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 neuron_id */ 1:
                    message.neuronId = reader.int32();
                    break;
                case /* repeated float values */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.values.push(reader.float());
                    else
                        message.values.push(reader.float());
                    break;
                case /* int32 H */ 3:
                    message.h = reader.int32();
                    break;
                case /* int32 W */ 4:
                    message.w = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActivationMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 neuron_id = 1; */
        if (message.neuronId !== 0)
            writer.tag(1, WireType.Varint).int32(message.neuronId);
        /* repeated float values = 2; */
        if (message.values.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.values.length; i++)
                writer.float(message.values[i]);
            writer.join();
        }
        /* int32 H = 3; */
        if (message.h !== 0)
            writer.tag(3, WireType.Varint).int32(message.h);
        /* int32 W = 4; */
        if (message.w !== 0)
            writer.tag(4, WireType.Varint).int32(message.w);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ActivationMap
 */
export const ActivationMap = new ActivationMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivationResponse$Type extends MessageType<ActivationResponse> {
    constructor() {
        super("ActivationResponse", [
            { no: 1, name: "layer_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "neurons_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "activations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ActivationMap }
        ]);
    }
    create(value?: PartialMessage<ActivationResponse>): ActivationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.layerType = "";
        message.neuronsCount = 0;
        message.activations = [];
        if (value !== undefined)
            reflectionMergePartial<ActivationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActivationResponse): ActivationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string layer_type */ 1:
                    message.layerType = reader.string();
                    break;
                case /* int32 neurons_count */ 2:
                    message.neuronsCount = reader.int32();
                    break;
                case /* repeated ActivationMap activations */ 3:
                    message.activations.push(ActivationMap.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActivationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string layer_type = 1; */
        if (message.layerType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.layerType);
        /* int32 neurons_count = 2; */
        if (message.neuronsCount !== 0)
            writer.tag(2, WireType.Varint).int32(message.neuronsCount);
        /* repeated ActivationMap activations = 3; */
        for (let i = 0; i < message.activations.length; i++)
            ActivationMap.internalBinaryWrite(message.activations[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ActivationResponse
 */
export const ActivationResponse = new ActivationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskField$Type extends MessageType<TaskField> {
    constructor() {
        super("TaskField", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "float_value", kind: "scalar", oneof: "value", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "int_value", kind: "scalar", oneof: "value", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "string_value", kind: "scalar", oneof: "value", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "bytes_value", kind: "scalar", oneof: "value", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "bool_value", kind: "scalar", oneof: "value", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TaskField>): TaskField {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.value = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<TaskField>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskField): TaskField {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* float float_value */ 2:
                    message.value = {
                        oneofKind: "floatValue",
                        floatValue: reader.float()
                    };
                    break;
                case /* int32 int_value */ 3:
                    message.value = {
                        oneofKind: "intValue",
                        intValue: reader.int32()
                    };
                    break;
                case /* string string_value */ 4:
                    message.value = {
                        oneofKind: "stringValue",
                        stringValue: reader.string()
                    };
                    break;
                case /* bytes bytes_value */ 5:
                    message.value = {
                        oneofKind: "bytesValue",
                        bytesValue: reader.bytes()
                    };
                    break;
                case /* bool bool_value */ 6:
                    message.value = {
                        oneofKind: "boolValue",
                        boolValue: reader.bool()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskField, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* float float_value = 2; */
        if (message.value.oneofKind === "floatValue")
            writer.tag(2, WireType.Bit32).float(message.value.floatValue);
        /* int32 int_value = 3; */
        if (message.value.oneofKind === "intValue")
            writer.tag(3, WireType.Varint).int32(message.value.intValue);
        /* string string_value = 4; */
        if (message.value.oneofKind === "stringValue")
            writer.tag(4, WireType.LengthDelimited).string(message.value.stringValue);
        /* bytes bytes_value = 5; */
        if (message.value.oneofKind === "bytesValue")
            writer.tag(5, WireType.LengthDelimited).bytes(message.value.bytesValue);
        /* bool bool_value = 6; */
        if (message.value.oneofKind === "boolValue")
            writer.tag(6, WireType.Varint).bool(message.value.boolValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TaskField
 */
export const TaskField = new TaskField$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordMetadata$Type extends MessageType<RecordMetadata> {
    constructor() {
        super("RecordMetadata", [
            { no: 1, name: "sample_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "sample_label", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "sample_prediction", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "sample_last_loss", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "sample_encounters", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "sample_discarded", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "extra_fields", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TaskField },
            { no: 9, name: "prediction_raw", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 10, name: "task_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RecordMetadata>): RecordMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sampleId = 0;
        message.sampleLabel = [];
        message.samplePrediction = [];
        message.sampleLastLoss = 0;
        message.sampleEncounters = 0;
        message.sampleDiscarded = false;
        message.extraFields = [];
        message.predictionRaw = new Uint8Array(0);
        message.taskType = "";
        if (value !== undefined)
            reflectionMergePartial<RecordMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecordMetadata): RecordMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 sample_id */ 1:
                    message.sampleId = reader.int32();
                    break;
                case /* repeated int32 sample_label */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.sampleLabel.push(reader.int32());
                    else
                        message.sampleLabel.push(reader.int32());
                    break;
                case /* repeated int32 sample_prediction */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.samplePrediction.push(reader.int32());
                    else
                        message.samplePrediction.push(reader.int32());
                    break;
                case /* float sample_last_loss */ 4:
                    message.sampleLastLoss = reader.float();
                    break;
                case /* int32 sample_encounters */ 5:
                    message.sampleEncounters = reader.int32();
                    break;
                case /* bool sample_discarded */ 6:
                    message.sampleDiscarded = reader.bool();
                    break;
                case /* repeated TaskField extra_fields */ 7:
                    message.extraFields.push(TaskField.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes prediction_raw */ 9:
                    message.predictionRaw = reader.bytes();
                    break;
                case /* string task_type */ 10:
                    message.taskType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecordMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 sample_id = 1; */
        if (message.sampleId !== 0)
            writer.tag(1, WireType.Varint).int32(message.sampleId);
        /* repeated int32 sample_label = 2; */
        if (message.sampleLabel.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.sampleLabel.length; i++)
                writer.int32(message.sampleLabel[i]);
            writer.join();
        }
        /* repeated int32 sample_prediction = 3; */
        if (message.samplePrediction.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.samplePrediction.length; i++)
                writer.int32(message.samplePrediction[i]);
            writer.join();
        }
        /* float sample_last_loss = 4; */
        if (message.sampleLastLoss !== 0)
            writer.tag(4, WireType.Bit32).float(message.sampleLastLoss);
        /* int32 sample_encounters = 5; */
        if (message.sampleEncounters !== 0)
            writer.tag(5, WireType.Varint).int32(message.sampleEncounters);
        /* bool sample_discarded = 6; */
        if (message.sampleDiscarded !== false)
            writer.tag(6, WireType.Varint).bool(message.sampleDiscarded);
        /* repeated TaskField extra_fields = 7; */
        for (let i = 0; i < message.extraFields.length; i++)
            TaskField.internalBinaryWrite(message.extraFields[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* bytes prediction_raw = 9; */
        if (message.predictionRaw.length)
            writer.tag(9, WireType.LengthDelimited).bytes(message.predictionRaw);
        /* string task_type = 10; */
        if (message.taskType !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.taskType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RecordMetadata
 */
export const RecordMetadata = new RecordMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SampleStatistics$Type extends MessageType<SampleStatistics> {
    constructor() {
        super("SampleStatistics", [
            { no: 6, name: "origin", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "sample_count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "task_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "records", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RecordMetadata }
        ]);
    }
    create(value?: PartialMessage<SampleStatistics>): SampleStatistics {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskType = "";
        message.records = [];
        if (value !== undefined)
            reflectionMergePartial<SampleStatistics>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SampleStatistics): SampleStatistics {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string origin */ 6:
                    message.origin = reader.string();
                    break;
                case /* optional int32 sample_count */ 7:
                    message.sampleCount = reader.int32();
                    break;
                case /* string task_type */ 9:
                    message.taskType = reader.string();
                    break;
                case /* repeated RecordMetadata records */ 8:
                    message.records.push(RecordMetadata.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SampleStatistics, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string origin = 6; */
        if (message.origin !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.origin);
        /* optional int32 sample_count = 7; */
        if (message.sampleCount !== undefined)
            writer.tag(7, WireType.Varint).int32(message.sampleCount);
        /* repeated RecordMetadata records = 8; */
        for (let i = 0; i < message.records.length; i++)
            RecordMetadata.internalBinaryWrite(message.records[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string task_type = 9; */
        if (message.taskType !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.taskType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SampleStatistics
 */
export const SampleStatistics = new SampleStatistics$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandResponse$Type extends MessageType<CommandResponse> {
    constructor() {
        super("CommandResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "hyper_parameters_descs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => HyperParameterDesc },
            { no: 4, name: "layer_representations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => LayerRepresentation },
            { no: 5, name: "sample_statistics", kind: "message", T: () => SampleStatistics }
        ]);
    }
    create(value?: PartialMessage<CommandResponse>): CommandResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        message.hyperParametersDescs = [];
        message.layerRepresentations = [];
        if (value !== undefined)
            reflectionMergePartial<CommandResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommandResponse): CommandResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* repeated HyperParameterDesc hyper_parameters_descs */ 3:
                    message.hyperParametersDescs.push(HyperParameterDesc.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated LayerRepresentation layer_representations */ 4:
                    message.layerRepresentations.push(LayerRepresentation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional SampleStatistics sample_statistics */ 5:
                    message.sampleStatistics = SampleStatistics.internalBinaryRead(reader, reader.uint32(), options, message.sampleStatistics);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommandResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* repeated HyperParameterDesc hyper_parameters_descs = 3; */
        for (let i = 0; i < message.hyperParametersDescs.length; i++)
            HyperParameterDesc.internalBinaryWrite(message.hyperParametersDescs[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated LayerRepresentation layer_representations = 4; */
        for (let i = 0; i < message.layerRepresentations.length; i++)
            LayerRepresentation.internalBinaryWrite(message.layerRepresentations[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional SampleStatistics sample_statistics = 5; */
        if (message.sampleStatistics)
            SampleStatistics.internalBinaryWrite(message.sampleStatistics, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CommandResponse
 */
export const CommandResponse = new CommandResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SampleRequest$Type extends MessageType<SampleRequest> {
    constructor() {
        super("SampleRequest", [
            { no: 1, name: "sample_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "origin", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SampleRequest>): SampleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SampleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SampleRequest): SampleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 sample_id */ 1:
                    message.sampleId = reader.int32();
                    break;
                case /* optional string origin */ 2:
                    message.origin = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SampleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 sample_id = 1; */
        if (message.sampleId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.sampleId);
        /* optional string origin = 2; */
        if (message.origin !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.origin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SampleRequest
 */
export const SampleRequest = new SampleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SampleRequestResponse$Type extends MessageType<SampleRequestResponse> {
    constructor() {
        super("SampleRequestResponse", [
            { no: 1, name: "sample_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "origin", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "label", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "error_message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "raw_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "mask", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "prediction", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SampleRequestResponse>): SampleRequestResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SampleRequestResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SampleRequestResponse): SampleRequestResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 sample_id */ 1:
                    message.sampleId = reader.int32();
                    break;
                case /* optional string origin */ 2:
                    message.origin = reader.string();
                    break;
                case /* optional int32 label */ 3:
                    message.label = reader.int32();
                    break;
                case /* optional bytes data */ 4:
                    message.data = reader.bytes();
                    break;
                case /* optional string error_message */ 5:
                    message.errorMessage = reader.string();
                    break;
                case /* optional bytes raw_data */ 6:
                    message.rawData = reader.bytes();
                    break;
                case /* optional bytes mask */ 7:
                    message.mask = reader.bytes();
                    break;
                case /* optional bytes prediction */ 8:
                    message.prediction = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SampleRequestResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 sample_id = 1; */
        if (message.sampleId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.sampleId);
        /* optional string origin = 2; */
        if (message.origin !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.origin);
        /* optional int32 label = 3; */
        if (message.label !== undefined)
            writer.tag(3, WireType.Varint).int32(message.label);
        /* optional bytes data = 4; */
        if (message.data !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.data);
        /* optional string error_message = 5; */
        if (message.errorMessage !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.errorMessage);
        /* optional bytes raw_data = 6; */
        if (message.rawData !== undefined)
            writer.tag(6, WireType.LengthDelimited).bytes(message.rawData);
        /* optional bytes mask = 7; */
        if (message.mask !== undefined)
            writer.tag(7, WireType.LengthDelimited).bytes(message.mask);
        /* optional bytes prediction = 8; */
        if (message.prediction !== undefined)
            writer.tag(8, WireType.LengthDelimited).bytes(message.prediction);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SampleRequestResponse
 */
export const SampleRequestResponse = new SampleRequestResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatchSampleRequest$Type extends MessageType<BatchSampleRequest> {
    constructor() {
        super("BatchSampleRequest", [
            { no: 1, name: "sample_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "origin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "resize_width", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "resize_height", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BatchSampleRequest>): BatchSampleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sampleIds = [];
        message.origin = "";
        if (value !== undefined)
            reflectionMergePartial<BatchSampleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchSampleRequest): BatchSampleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 sample_ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.sampleIds.push(reader.int32());
                    else
                        message.sampleIds.push(reader.int32());
                    break;
                case /* string origin */ 2:
                    message.origin = reader.string();
                    break;
                case /* optional int32 resize_width */ 3:
                    message.resizeWidth = reader.int32();
                    break;
                case /* optional int32 resize_height */ 4:
                    message.resizeHeight = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BatchSampleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 sample_ids = 1; */
        if (message.sampleIds.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.sampleIds.length; i++)
                writer.int32(message.sampleIds[i]);
            writer.join();
        }
        /* string origin = 2; */
        if (message.origin !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.origin);
        /* optional int32 resize_width = 3; */
        if (message.resizeWidth !== undefined)
            writer.tag(3, WireType.Varint).int32(message.resizeWidth);
        /* optional int32 resize_height = 4; */
        if (message.resizeHeight !== undefined)
            writer.tag(4, WireType.Varint).int32(message.resizeHeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BatchSampleRequest
 */
export const BatchSampleRequest = new BatchSampleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatchSampleResponse$Type extends MessageType<BatchSampleResponse> {
    constructor() {
        super("BatchSampleResponse", [
            { no: 1, name: "samples", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SampleRequestResponse }
        ]);
    }
    create(value?: PartialMessage<BatchSampleResponse>): BatchSampleResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.samples = [];
        if (value !== undefined)
            reflectionMergePartial<BatchSampleResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchSampleResponse): BatchSampleResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated SampleRequestResponse samples */ 1:
                    message.samples.push(SampleRequestResponse.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BatchSampleResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated SampleRequestResponse samples = 1; */
        for (let i = 0; i < message.samples.length; i++)
            SampleRequestResponse.internalBinaryWrite(message.samples[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BatchSampleResponse
 */
export const BatchSampleResponse = new BatchSampleResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WeightsRequest$Type extends MessageType<WeightsRequest> {
    constructor() {
        super("WeightsRequest", [
            { no: 1, name: "neuron_id", kind: "message", T: () => NeuronId }
        ]);
    }
    create(value?: PartialMessage<WeightsRequest>): WeightsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<WeightsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WeightsRequest): WeightsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* NeuronId neuron_id */ 1:
                    message.neuronId = NeuronId.internalBinaryRead(reader, reader.uint32(), options, message.neuronId);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WeightsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* NeuronId neuron_id = 1; */
        if (message.neuronId)
            NeuronId.internalBinaryWrite(message.neuronId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WeightsRequest
 */
export const WeightsRequest = new WeightsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WeightsResponse$Type extends MessageType<WeightsResponse> {
    constructor() {
        super("WeightsResponse", [
            { no: 1, name: "neuron_id", kind: "message", T: () => NeuronId },
            { no: 2, name: "layer_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "layer_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "incoming", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "outgoing", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "kernel_size", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "weights", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "error_message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WeightsResponse>): WeightsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.incoming = 0;
        message.outgoing = 0;
        message.weights = [];
        message.success = false;
        if (value !== undefined)
            reflectionMergePartial<WeightsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WeightsResponse): WeightsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* NeuronId neuron_id */ 1:
                    message.neuronId = NeuronId.internalBinaryRead(reader, reader.uint32(), options, message.neuronId);
                    break;
                case /* optional string layer_name */ 2:
                    message.layerName = reader.string();
                    break;
                case /* optional string layer_type */ 3:
                    message.layerType = reader.string();
                    break;
                case /* int32 incoming */ 4:
                    message.incoming = reader.int32();
                    break;
                case /* int32 outgoing */ 5:
                    message.outgoing = reader.int32();
                    break;
                case /* optional int32 kernel_size */ 6:
                    message.kernelSize = reader.int32();
                    break;
                case /* repeated float weights */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.weights.push(reader.float());
                    else
                        message.weights.push(reader.float());
                    break;
                case /* bool success */ 11:
                    message.success = reader.bool();
                    break;
                case /* optional string error_message */ 12:
                    message.errorMessage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WeightsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* NeuronId neuron_id = 1; */
        if (message.neuronId)
            NeuronId.internalBinaryWrite(message.neuronId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional string layer_name = 2; */
        if (message.layerName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.layerName);
        /* optional string layer_type = 3; */
        if (message.layerType !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.layerType);
        /* int32 incoming = 4; */
        if (message.incoming !== 0)
            writer.tag(4, WireType.Varint).int32(message.incoming);
        /* int32 outgoing = 5; */
        if (message.outgoing !== 0)
            writer.tag(5, WireType.Varint).int32(message.outgoing);
        /* optional int32 kernel_size = 6; */
        if (message.kernelSize !== undefined)
            writer.tag(6, WireType.Varint).int32(message.kernelSize);
        /* repeated float weights = 7; */
        if (message.weights.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.weights.length; i++)
                writer.float(message.weights[i]);
            writer.join();
        }
        /* bool success = 11; */
        if (message.success !== false)
            writer.tag(11, WireType.Varint).bool(message.success);
        /* optional string error_message = 12; */
        if (message.errorMessage !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.errorMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message WeightsResponse
 */
export const WeightsResponse = new WeightsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataQueryRequest$Type extends MessageType<DataQueryRequest> {
    constructor() {
        super("DataQueryRequest", [
            { no: 1, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "accumulate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "is_natural_language", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DataQueryRequest>): DataQueryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.query = "";
        message.accumulate = false;
        message.isNaturalLanguage = false;
        if (value !== undefined)
            reflectionMergePartial<DataQueryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataQueryRequest): DataQueryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string query */ 1:
                    message.query = reader.string();
                    break;
                case /* bool accumulate */ 2:
                    message.accumulate = reader.bool();
                    break;
                case /* bool is_natural_language */ 3:
                    message.isNaturalLanguage = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DataQueryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string query = 1; */
        if (message.query !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.query);
        /* bool accumulate = 2; */
        if (message.accumulate !== false)
            writer.tag(2, WireType.Varint).bool(message.accumulate);
        /* bool is_natural_language = 3; */
        if (message.isNaturalLanguage !== false)
            writer.tag(3, WireType.Varint).bool(message.isNaturalLanguage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DataQueryRequest
 */
export const DataQueryRequest = new DataQueryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataQueryResponse$Type extends MessageType<DataQueryResponse> {
    constructor() {
        super("DataQueryResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "number_of_all_samples", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "number_of_samples_in_the_loop", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "number_of_discarded_samples", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<DataQueryResponse>): DataQueryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        message.numberOfAllSamples = 0;
        message.numberOfSamplesInTheLoop = 0;
        message.numberOfDiscardedSamples = 0;
        if (value !== undefined)
            reflectionMergePartial<DataQueryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataQueryResponse): DataQueryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* int32 number_of_all_samples */ 3:
                    message.numberOfAllSamples = reader.int32();
                    break;
                case /* int32 number_of_samples_in_the_loop */ 4:
                    message.numberOfSamplesInTheLoop = reader.int32();
                    break;
                case /* int32 number_of_discarded_samples */ 5:
                    message.numberOfDiscardedSamples = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DataQueryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* int32 number_of_all_samples = 3; */
        if (message.numberOfAllSamples !== 0)
            writer.tag(3, WireType.Varint).int32(message.numberOfAllSamples);
        /* int32 number_of_samples_in_the_loop = 4; */
        if (message.numberOfSamplesInTheLoop !== 0)
            writer.tag(4, WireType.Varint).int32(message.numberOfSamplesInTheLoop);
        /* int32 number_of_discarded_samples = 5; */
        if (message.numberOfDiscardedSamples !== 0)
            writer.tag(5, WireType.Varint).int32(message.numberOfDiscardedSamples);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DataQueryResponse
 */
export const DataQueryResponse = new DataQueryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataSamplesRequest$Type extends MessageType<DataSamplesRequest> {
    constructor() {
        super("DataSamplesRequest", [
            { no: 1, name: "start_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "records_cnt", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "include_transformed_data", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "include_raw_data", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "stats_to_retrieve", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DataSamplesRequest>): DataSamplesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.startIndex = 0;
        message.recordsCnt = 0;
        message.includeTransformedData = false;
        message.includeRawData = false;
        message.statsToRetrieve = [];
        if (value !== undefined)
            reflectionMergePartial<DataSamplesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataSamplesRequest): DataSamplesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 start_index */ 1:
                    message.startIndex = reader.int32();
                    break;
                case /* int32 records_cnt */ 2:
                    message.recordsCnt = reader.int32();
                    break;
                case /* bool include_transformed_data */ 3:
                    message.includeTransformedData = reader.bool();
                    break;
                case /* bool include_raw_data */ 4:
                    message.includeRawData = reader.bool();
                    break;
                case /* repeated string stats_to_retrieve */ 5:
                    message.statsToRetrieve.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DataSamplesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 start_index = 1; */
        if (message.startIndex !== 0)
            writer.tag(1, WireType.Varint).int32(message.startIndex);
        /* int32 records_cnt = 2; */
        if (message.recordsCnt !== 0)
            writer.tag(2, WireType.Varint).int32(message.recordsCnt);
        /* bool include_transformed_data = 3; */
        if (message.includeTransformedData !== false)
            writer.tag(3, WireType.Varint).bool(message.includeTransformedData);
        /* bool include_raw_data = 4; */
        if (message.includeRawData !== false)
            writer.tag(4, WireType.Varint).bool(message.includeRawData);
        /* repeated string stats_to_retrieve = 5; */
        for (let i = 0; i < message.statsToRetrieve.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.statsToRetrieve[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DataSamplesRequest
 */
export const DataSamplesRequest = new DataSamplesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataStat$Type extends MessageType<DataStat> {
    constructor() {
        super("DataStat", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "shape", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "value", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "value_string", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DataStat>): DataStat {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.type = "";
        message.shape = [];
        message.value = [];
        message.valueString = "";
        if (value !== undefined)
            reflectionMergePartial<DataStat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataStat): DataStat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string type */ 2:
                    message.type = reader.string();
                    break;
                case /* repeated int32 shape */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.shape.push(reader.int32());
                    else
                        message.shape.push(reader.int32());
                    break;
                case /* repeated float value */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.value.push(reader.float());
                    else
                        message.value.push(reader.float());
                    break;
                case /* string value_string */ 5:
                    message.valueString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DataStat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string type = 2; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* repeated int32 shape = 3; */
        if (message.shape.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.shape.length; i++)
                writer.int32(message.shape[i]);
            writer.join();
        }
        /* repeated float value = 4; */
        if (message.value.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.value.length; i++)
                writer.float(message.value[i]);
            writer.join();
        }
        /* string value_string = 5; */
        if (message.valueString !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.valueString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DataStat
 */
export const DataStat = new DataStat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataRecord$Type extends MessageType<DataRecord> {
    constructor() {
        super("DataRecord", [
            { no: 1, name: "sample_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "data_stats", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DataStat }
        ]);
    }
    create(value?: PartialMessage<DataRecord>): DataRecord {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sampleId = 0;
        message.dataStats = [];
        if (value !== undefined)
            reflectionMergePartial<DataRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataRecord): DataRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 sample_id */ 1:
                    message.sampleId = reader.int32();
                    break;
                case /* repeated DataStat data_stats */ 2:
                    message.dataStats.push(DataStat.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DataRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 sample_id = 1; */
        if (message.sampleId !== 0)
            writer.tag(1, WireType.Varint).int32(message.sampleId);
        /* repeated DataStat data_stats = 2; */
        for (let i = 0; i < message.dataStats.length; i++)
            DataStat.internalBinaryWrite(message.dataStats[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DataRecord
 */
export const DataRecord = new DataRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataSamplesResponse$Type extends MessageType<DataSamplesResponse> {
    constructor() {
        super("DataSamplesResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "data_records", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DataRecord }
        ]);
    }
    create(value?: PartialMessage<DataSamplesResponse>): DataSamplesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        message.dataRecords = [];
        if (value !== undefined)
            reflectionMergePartial<DataSamplesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataSamplesResponse): DataSamplesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* repeated DataRecord data_records */ 3:
                    message.dataRecords.push(DataRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DataSamplesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* repeated DataRecord data_records = 3; */
        for (let i = 0; i < message.dataRecords.length; i++)
            DataRecord.internalBinaryWrite(message.dataRecords[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DataSamplesResponse
 */
export const DataSamplesResponse = new DataSamplesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataEditsRequest$Type extends MessageType<DataEditsRequest> {
    constructor() {
        super("DataEditsRequest", [
            { no: 1, name: "stat_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "float_value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "string_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "bool_value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "type", kind: "enum", T: () => ["SampleEditType", SampleEditType] },
            { no: 6, name: "samples_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "sample_origins", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DataEditsRequest>): DataEditsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statName = "";
        message.floatValue = 0;
        message.stringValue = "";
        message.boolValue = false;
        message.type = 0;
        message.samplesIds = [];
        message.sampleOrigins = [];
        if (value !== undefined)
            reflectionMergePartial<DataEditsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataEditsRequest): DataEditsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string stat_name */ 1:
                    message.statName = reader.string();
                    break;
                case /* float float_value */ 2:
                    message.floatValue = reader.float();
                    break;
                case /* string string_value */ 3:
                    message.stringValue = reader.string();
                    break;
                case /* bool bool_value */ 4:
                    message.boolValue = reader.bool();
                    break;
                case /* SampleEditType type */ 5:
                    message.type = reader.int32();
                    break;
                case /* repeated int32 samples_ids */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.samplesIds.push(reader.int32());
                    else
                        message.samplesIds.push(reader.int32());
                    break;
                case /* repeated string sample_origins */ 7:
                    message.sampleOrigins.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DataEditsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string stat_name = 1; */
        if (message.statName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.statName);
        /* float float_value = 2; */
        if (message.floatValue !== 0)
            writer.tag(2, WireType.Bit32).float(message.floatValue);
        /* string string_value = 3; */
        if (message.stringValue !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.stringValue);
        /* bool bool_value = 4; */
        if (message.boolValue !== false)
            writer.tag(4, WireType.Varint).bool(message.boolValue);
        /* SampleEditType type = 5; */
        if (message.type !== 0)
            writer.tag(5, WireType.Varint).int32(message.type);
        /* repeated int32 samples_ids = 6; */
        if (message.samplesIds.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.samplesIds.length; i++)
                writer.int32(message.samplesIds[i]);
            writer.join();
        }
        /* repeated string sample_origins = 7; */
        for (let i = 0; i < message.sampleOrigins.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.sampleOrigins[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DataEditsRequest
 */
export const DataEditsRequest = new DataEditsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataEditsResponse$Type extends MessageType<DataEditsResponse> {
    constructor() {
        super("DataEditsResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DataEditsResponse>): DataEditsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<DataEditsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataEditsResponse): DataEditsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DataEditsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DataEditsResponse
 */
export const DataEditsResponse = new DataEditsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataStreamRequest$Type extends MessageType<DataStreamRequest> {
    constructor() {
        super("DataStreamRequest", [
            { no: 1, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "is_natural_language", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "max_samples", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "start_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<DataStreamRequest>): DataStreamRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.query = "";
        message.isNaturalLanguage = false;
        message.maxSamples = 0;
        message.startIndex = 0;
        if (value !== undefined)
            reflectionMergePartial<DataStreamRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataStreamRequest): DataStreamRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string query */ 1:
                    message.query = reader.string();
                    break;
                case /* bool is_natural_language */ 2:
                    message.isNaturalLanguage = reader.bool();
                    break;
                case /* int32 max_samples */ 3:
                    message.maxSamples = reader.int32();
                    break;
                case /* int32 start_index */ 4:
                    message.startIndex = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DataStreamRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string query = 1; */
        if (message.query !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.query);
        /* bool is_natural_language = 2; */
        if (message.isNaturalLanguage !== false)
            writer.tag(2, WireType.Varint).bool(message.isNaturalLanguage);
        /* int32 max_samples = 3; */
        if (message.maxSamples !== 0)
            writer.tag(3, WireType.Varint).int32(message.maxSamples);
        /* int32 start_index = 4; */
        if (message.startIndex !== 0)
            writer.tag(4, WireType.Varint).int32(message.startIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DataStreamRequest
 */
export const DataStreamRequest = new DataStreamRequest$Type();
/**
 * @generated ServiceType for protobuf service ExperimentService
 */
export const ExperimentService = new ServiceType("ExperimentService", [
    { name: "StreamStatus", serverStreaming: true, options: {}, I: Empty, O: TrainingStatusEx },
    { name: "ExperimentCommand", options: {}, I: TrainerCommand, O: CommandResponse },
    { name: "ManipulateWeights", options: {}, I: WeightsOperationRequest, O: WeightsOperationResponse },
    { name: "GetWeights", options: {}, I: WeightsRequest, O: WeightsResponse },
    { name: "GetActivations", options: {}, I: ActivationRequest, O: ActivationResponse },
    { name: "GetSamples", options: {}, I: BatchSampleRequest, O: BatchSampleResponse },
    { name: "ApplyDataQuery", options: {}, I: DataQueryRequest, O: DataQueryResponse },
    { name: "GetDataSamples", options: {}, I: DataSamplesRequest, O: DataSamplesResponse },
    { name: "EditDataSample", options: {}, I: DataEditsRequest, O: DataEditsResponse },
    { name: "StreamDataUpdates", serverStreaming: true, options: {}, I: DataStreamRequest, O: DataSamplesResponse }
]);

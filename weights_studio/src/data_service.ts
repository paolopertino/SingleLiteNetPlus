// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "data_service.proto" (syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message QueryRequest
 */
export interface QueryRequest {
    /**
     * @generated from protobuf field: string query = 1
     */
    query: string; // The query string to be applied
    /**
     * @generated from protobuf field: bool accumulate = 2
     */
    accumulate: boolean; // Whether to accumulate with existing query
    /**
     * @generated from protobuf field: bool is_natural_language = 3
     */
    isNaturalLanguage: boolean; // Whether the query is in natural language
}
/**
 * @generated from protobuf message QueryResponse
 */
export interface QueryResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * @generated from protobuf field: int32 number_of_all_samples = 3
     */
    numberOfAllSamples: number;
    /**
     * @generated from protobuf field: int32 number_of_samples_in_the_loop = 4
     */
    numberOfSamplesInTheLoop: number; // both eval and train
    /**
     * @generated from protobuf field: int32 number_of_discarded_samples = 5
     */
    numberOfDiscardedSamples: number; // both eval and train
}
/**
 *
 * Request to get data records along with specified statistics. This is meant
 * for fast and efficient data retrieval.
 *
 * @generated from protobuf message SamplesRequest
 */
export interface SamplesRequest {
    /**
     * @generated from protobuf field: int32 start_index = 1
     */
    startIndex: number;
    /**
     * @generated from protobuf field: int32 records_cnt = 2
     */
    recordsCnt: number;
    /**
     * @generated from protobuf field: bool include_transformed_data = 3
     */
    includeTransformedData: boolean; // Whether to include model ready data
    /**
     * @generated from protobuf field: bool include_raw_data = 4
     */
    includeRawData: boolean; // Whether to include raw data
    /**
     * @generated from protobuf field: repeated string stats_to_retrieve = 5
     */
    statsToRetrieve: string[]; // if empty return all stats
}
/**
 * Represents a single data statistic, such as target, latest_prediction,
 * latest_loss, encounters, discarded and any extra fields.
 *
 * @generated from protobuf message DataStat
 */
export interface DataStat {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: string type = 2
     */
    type: string;
    /**
     * @generated from protobuf field: repeated int32 shape = 3
     */
    shape: number[];
    /**
     * @generated from protobuf field: repeated float value = 4
     */
    value: number[];
    /**
     * @generated from protobuf field: string value_string = 5
     */
    valueString: string;
}
/**
 * @generated from protobuf message DataRecord
 */
export interface DataRecord {
    /**
     * @generated from protobuf field: int32 sample_id = 1
     */
    sampleId: number;
    /**
     * @generated from protobuf field: repeated DataStat data_stats = 2
     */
    dataStats: DataStat[];
}
/**
 * @generated from protobuf message SamplesResponse
 */
export interface SamplesResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * @generated from protobuf field: repeated DataRecord data_records = 3
     */
    dataRecords: DataRecord[];
}
/**
 * @generated from protobuf message StatsRequest
 */
export interface StatsRequest {
    /**
     * Runs statistics on the resulting set of samples after running the predicate
     *
     * @generated from protobuf field: optional string predicate = 1
     */
    predicate?: string;
}
/**
 * @generated from protobuf message StatName2Aggregation
 */
export interface StatName2Aggregation {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: float value = 2
     */
    value: number;
}
/**
 * @generated from protobuf message StatsResponse
 */
export interface StatsResponse {
    /**
     * @generated from protobuf field: repeated StatName2Aggregation statistics = 1
     */
    statistics: StatName2Aggregation[];
}
/**
 * @generated from protobuf message EditsRequest
 */
export interface EditsRequest {
    /**
     * @generated from protobuf field: string stat_name = 1
     */
    statName: string;
    /**
     * @generated from protobuf field: float float_value = 2
     */
    floatValue: number;
    /**
     * @generated from protobuf field: string string_value = 3
     */
    stringValue: string;
    /**
     * @generated from protobuf field: bool bool_value = 7
     */
    boolValue: boolean;
    /**
     * @generated from protobuf field: SampleEditType type = 4
     */
    type: SampleEditType;
    /**
     * @generated from protobuf field: repeated int32 samples_ids = 5
     */
    samplesIds: number[];
    /**
     * @generated from protobuf field: repeated string sample_origins = 6
     */
    sampleOrigins: string[];
}
/**
 * @generated from protobuf message EditsResponse
 */
export interface EditsResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
/**
 * @generated from protobuf enum SampleEditType
 */
export enum SampleEditType {
    /**
     * @generated from protobuf enum value: OVERRIDE = 0;
     */
    OVERRIDE = 0,
    /**
     * @generated from protobuf enum value: ACCUMULATE = 1;
     */
    ACCUMULATE = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class QueryRequest$Type extends MessageType<QueryRequest> {
    constructor() {
        super("QueryRequest", [
            { no: 1, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "accumulate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "is_natural_language", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<QueryRequest>): QueryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.query = "";
        message.accumulate = false;
        message.isNaturalLanguage = false;
        if (value !== undefined)
            reflectionMergePartial<QueryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryRequest): QueryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string query */ 1:
                    message.query = reader.string();
                    break;
                case /* bool accumulate */ 2:
                    message.accumulate = reader.bool();
                    break;
                case /* bool is_natural_language */ 3:
                    message.isNaturalLanguage = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string query = 1; */
        if (message.query !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.query);
        /* bool accumulate = 2; */
        if (message.accumulate !== false)
            writer.tag(2, WireType.Varint).bool(message.accumulate);
        /* bool is_natural_language = 3; */
        if (message.isNaturalLanguage !== false)
            writer.tag(3, WireType.Varint).bool(message.isNaturalLanguage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message QueryRequest
 */
export const QueryRequest = new QueryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryResponse$Type extends MessageType<QueryResponse> {
    constructor() {
        super("QueryResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "number_of_all_samples", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "number_of_samples_in_the_loop", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "number_of_discarded_samples", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<QueryResponse>): QueryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        message.numberOfAllSamples = 0;
        message.numberOfSamplesInTheLoop = 0;
        message.numberOfDiscardedSamples = 0;
        if (value !== undefined)
            reflectionMergePartial<QueryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryResponse): QueryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* int32 number_of_all_samples */ 3:
                    message.numberOfAllSamples = reader.int32();
                    break;
                case /* int32 number_of_samples_in_the_loop */ 4:
                    message.numberOfSamplesInTheLoop = reader.int32();
                    break;
                case /* int32 number_of_discarded_samples */ 5:
                    message.numberOfDiscardedSamples = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* int32 number_of_all_samples = 3; */
        if (message.numberOfAllSamples !== 0)
            writer.tag(3, WireType.Varint).int32(message.numberOfAllSamples);
        /* int32 number_of_samples_in_the_loop = 4; */
        if (message.numberOfSamplesInTheLoop !== 0)
            writer.tag(4, WireType.Varint).int32(message.numberOfSamplesInTheLoop);
        /* int32 number_of_discarded_samples = 5; */
        if (message.numberOfDiscardedSamples !== 0)
            writer.tag(5, WireType.Varint).int32(message.numberOfDiscardedSamples);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message QueryResponse
 */
export const QueryResponse = new QueryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SamplesRequest$Type extends MessageType<SamplesRequest> {
    constructor() {
        super("SamplesRequest", [
            { no: 1, name: "start_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "records_cnt", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "include_transformed_data", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "include_raw_data", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "stats_to_retrieve", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SamplesRequest>): SamplesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.startIndex = 0;
        message.recordsCnt = 0;
        message.includeTransformedData = false;
        message.includeRawData = false;
        message.statsToRetrieve = [];
        if (value !== undefined)
            reflectionMergePartial<SamplesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SamplesRequest): SamplesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 start_index */ 1:
                    message.startIndex = reader.int32();
                    break;
                case /* int32 records_cnt */ 2:
                    message.recordsCnt = reader.int32();
                    break;
                case /* bool include_transformed_data */ 3:
                    message.includeTransformedData = reader.bool();
                    break;
                case /* bool include_raw_data */ 4:
                    message.includeRawData = reader.bool();
                    break;
                case /* repeated string stats_to_retrieve */ 5:
                    message.statsToRetrieve.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SamplesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 start_index = 1; */
        if (message.startIndex !== 0)
            writer.tag(1, WireType.Varint).int32(message.startIndex);
        /* int32 records_cnt = 2; */
        if (message.recordsCnt !== 0)
            writer.tag(2, WireType.Varint).int32(message.recordsCnt);
        /* bool include_transformed_data = 3; */
        if (message.includeTransformedData !== false)
            writer.tag(3, WireType.Varint).bool(message.includeTransformedData);
        /* bool include_raw_data = 4; */
        if (message.includeRawData !== false)
            writer.tag(4, WireType.Varint).bool(message.includeRawData);
        /* repeated string stats_to_retrieve = 5; */
        for (let i = 0; i < message.statsToRetrieve.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.statsToRetrieve[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SamplesRequest
 */
export const SamplesRequest = new SamplesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataStat$Type extends MessageType<DataStat> {
    constructor() {
        super("DataStat", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "shape", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "value", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "value_string", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DataStat>): DataStat {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.type = "";
        message.shape = [];
        message.value = [];
        message.valueString = "";
        if (value !== undefined)
            reflectionMergePartial<DataStat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataStat): DataStat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string type */ 2:
                    message.type = reader.string();
                    break;
                case /* repeated int32 shape */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.shape.push(reader.int32());
                    else
                        message.shape.push(reader.int32());
                    break;
                case /* repeated float value */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.value.push(reader.float());
                    else
                        message.value.push(reader.float());
                    break;
                case /* string value_string */ 5:
                    message.valueString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DataStat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string type = 2; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* repeated int32 shape = 3; */
        if (message.shape.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.shape.length; i++)
                writer.int32(message.shape[i]);
            writer.join();
        }
        /* repeated float value = 4; */
        if (message.value.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.value.length; i++)
                writer.float(message.value[i]);
            writer.join();
        }
        /* string value_string = 5; */
        if (message.valueString !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.valueString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DataStat
 */
export const DataStat = new DataStat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataRecord$Type extends MessageType<DataRecord> {
    constructor() {
        super("DataRecord", [
            { no: 1, name: "sample_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "data_stats", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DataStat }
        ]);
    }
    create(value?: PartialMessage<DataRecord>): DataRecord {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sampleId = 0;
        message.dataStats = [];
        if (value !== undefined)
            reflectionMergePartial<DataRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataRecord): DataRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 sample_id */ 1:
                    message.sampleId = reader.int32();
                    break;
                case /* repeated DataStat data_stats */ 2:
                    message.dataStats.push(DataStat.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DataRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 sample_id = 1; */
        if (message.sampleId !== 0)
            writer.tag(1, WireType.Varint).int32(message.sampleId);
        /* repeated DataStat data_stats = 2; */
        for (let i = 0; i < message.dataStats.length; i++)
            DataStat.internalBinaryWrite(message.dataStats[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DataRecord
 */
export const DataRecord = new DataRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SamplesResponse$Type extends MessageType<SamplesResponse> {
    constructor() {
        super("SamplesResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "data_records", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DataRecord }
        ]);
    }
    create(value?: PartialMessage<SamplesResponse>): SamplesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        message.dataRecords = [];
        if (value !== undefined)
            reflectionMergePartial<SamplesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SamplesResponse): SamplesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* repeated DataRecord data_records */ 3:
                    message.dataRecords.push(DataRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SamplesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* repeated DataRecord data_records = 3; */
        for (let i = 0; i < message.dataRecords.length; i++)
            DataRecord.internalBinaryWrite(message.dataRecords[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SamplesResponse
 */
export const SamplesResponse = new SamplesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatsRequest$Type extends MessageType<StatsRequest> {
    constructor() {
        super("StatsRequest", [
            { no: 1, name: "predicate", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StatsRequest>): StatsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StatsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatsRequest): StatsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string predicate */ 1:
                    message.predicate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string predicate = 1; */
        if (message.predicate !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.predicate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StatsRequest
 */
export const StatsRequest = new StatsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatName2Aggregation$Type extends MessageType<StatName2Aggregation> {
    constructor() {
        super("StatName2Aggregation", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<StatName2Aggregation>): StatName2Aggregation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.value = 0;
        if (value !== undefined)
            reflectionMergePartial<StatName2Aggregation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatName2Aggregation): StatName2Aggregation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* float value */ 2:
                    message.value = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatName2Aggregation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* float value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Bit32).float(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StatName2Aggregation
 */
export const StatName2Aggregation = new StatName2Aggregation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatsResponse$Type extends MessageType<StatsResponse> {
    constructor() {
        super("StatsResponse", [
            { no: 1, name: "statistics", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StatName2Aggregation }
        ]);
    }
    create(value?: PartialMessage<StatsResponse>): StatsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statistics = [];
        if (value !== undefined)
            reflectionMergePartial<StatsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatsResponse): StatsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated StatName2Aggregation statistics */ 1:
                    message.statistics.push(StatName2Aggregation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated StatName2Aggregation statistics = 1; */
        for (let i = 0; i < message.statistics.length; i++)
            StatName2Aggregation.internalBinaryWrite(message.statistics[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StatsResponse
 */
export const StatsResponse = new StatsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EditsRequest$Type extends MessageType<EditsRequest> {
    constructor() {
        super("EditsRequest", [
            { no: 1, name: "stat_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "float_value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "string_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "bool_value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "type", kind: "enum", T: () => ["SampleEditType", SampleEditType] },
            { no: 5, name: "samples_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "sample_origins", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EditsRequest>): EditsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statName = "";
        message.floatValue = 0;
        message.stringValue = "";
        message.boolValue = false;
        message.type = 0;
        message.samplesIds = [];
        message.sampleOrigins = [];
        if (value !== undefined)
            reflectionMergePartial<EditsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EditsRequest): EditsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string stat_name */ 1:
                    message.statName = reader.string();
                    break;
                case /* float float_value */ 2:
                    message.floatValue = reader.float();
                    break;
                case /* string string_value */ 3:
                    message.stringValue = reader.string();
                    break;
                case /* bool bool_value */ 7:
                    message.boolValue = reader.bool();
                    break;
                case /* SampleEditType type */ 4:
                    message.type = reader.int32();
                    break;
                case /* repeated int32 samples_ids */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.samplesIds.push(reader.int32());
                    else
                        message.samplesIds.push(reader.int32());
                    break;
                case /* repeated string sample_origins */ 6:
                    message.sampleOrigins.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EditsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string stat_name = 1; */
        if (message.statName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.statName);
        /* float float_value = 2; */
        if (message.floatValue !== 0)
            writer.tag(2, WireType.Bit32).float(message.floatValue);
        /* string string_value = 3; */
        if (message.stringValue !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.stringValue);
        /* SampleEditType type = 4; */
        if (message.type !== 0)
            writer.tag(4, WireType.Varint).int32(message.type);
        /* repeated int32 samples_ids = 5; */
        if (message.samplesIds.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.samplesIds.length; i++)
                writer.int32(message.samplesIds[i]);
            writer.join();
        }
        /* repeated string sample_origins = 6; */
        for (let i = 0; i < message.sampleOrigins.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.sampleOrigins[i]);
        /* bool bool_value = 7; */
        if (message.boolValue !== false)
            writer.tag(7, WireType.Varint).bool(message.boolValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EditsRequest
 */
export const EditsRequest = new EditsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EditsResponse$Type extends MessageType<EditsResponse> {
    constructor() {
        super("EditsResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EditsResponse>): EditsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<EditsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EditsResponse): EditsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EditsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EditsResponse
 */
export const EditsResponse = new EditsResponse$Type();
/**
 * @generated ServiceType for protobuf service DataService
 */
export const DataService = new ServiceType("DataService", [
    { name: "ApplyQuery", options: {}, I: QueryRequest, O: QueryResponse },
    { name: "GetSamples", options: {}, I: SamplesRequest, O: SamplesResponse },
    { name: "Statistics", options: {}, I: StatsRequest, O: StatsResponse },
    { name: "EditSample", options: {}, I: EditsRequest, O: EditsResponse }
]);
